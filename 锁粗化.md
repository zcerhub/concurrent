### 锁粗化

如果一系列的连续操作都对同一对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁的进行互斥操作也会导致不必要的性能损耗。

如果虚拟机探测到有这样一串零碎的操作都会对同一个对象加锁，将会把锁同步的范围扩展（粗化）到整个操作序列的外部（由多次加锁改为只加锁一次）。

通常情况下，为了保证多线程间的有限并发，会要求每个线程持有锁的时间尽可能的短，但是某些情况下，一个程序对同一个锁不间断的、高频的请求、同步和释放，会消耗掉一定的系统资源，因为锁的请求、同步和释放本身会带来系统消耗，这样高频的锁请求反而不利于系统性能的优化，虽然单次同步操作的时间可能很短。

### 样例展示

- 场景1

  ```
  public void doSomethingMethod(){
      synchronized(lock){
          //do some thing
      }
      //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕
      synchronized(lock){
          //do other thing
      }
  }
  ```

  可将合并两次的同步为一次，减少一次锁的请求、同步和释放的系统消耗。

- 场景2

  ```
  for(int i=0;i<size;i++){
      synchronized(lock){
      }
  }
  ```

  锁粗化后的代码

  ```
  synchronized(lock){
      for(int i=0;i<size;i++){
      }
  }
  ```

  

锁粗化的前提：中间不需要同步的代码能很快速的完成，如果不需要同步的代码需要很长的时间就会导致同步块需要很长的时间才能完成，这样做也就不合理了。



### 参考文献

- [锁优化](https://houbb.github.io/2018/10/08/jvm-30-lock-optimize#%E9%94%81%E4%BC%98%E5%8C%96)